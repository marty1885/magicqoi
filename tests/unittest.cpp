#include <magicqoi.h>

#include <random>
#include <iostream>
#include <cstring>

#include <qoi.h>

#include <catch2/catch_test_macros.hpp>
#include <catch2/catch_session.hpp>

TEST_CASE("Random QOI encode decode")
{
    std::vector<uint8_t> raw_pix(256 * 256 * 4);
    std::mt19937 gen(0);
    std::uniform_int_distribution<uint8_t> dis(0, 255);
    for(auto& p : raw_pix) {
        p = dis(gen);
    }

    size_t out_size;
    auto out_buf = magicqoi_encode_mem(raw_pix.data(), 256, 256, 4, &out_size);
    REQUIRE(out_buf != nullptr);

    uint32_t width, height, channels;
    auto decoded = magicqoi_decode_mem(out_buf, out_size, &width, &height, &channels);
    REQUIRE(decoded != nullptr);

    REQUIRE(width == 256);
    REQUIRE(height == 256);
    REQUIRE(channels == 4);
    CHECK(memcmp(raw_pix.data(), decoded, raw_pix.size()) == 0);

    free(out_buf);
    free(decoded);
}

// 100x100 image with 3 channels green image
std::vector<uint8_t> qoi_green_square = {0x71, 0x6f, 0x69, 0x66, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x03, 0x00, 0xfe, 0x3f, 0xca, 0xb8, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd
, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd
, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd
, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd
, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd
, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd
, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};

TEST_CASE("Good minimal QOI decode") {
    uint32_t width, height, channels;
    auto decoded = magicqoi_decode_mem(qoi_green_square.data(), qoi_green_square.size(), &width, &height, &channels);
    REQUIRE(decoded != nullptr);
    REQUIRE(width == 100);
    REQUIRE(height == 100);
    REQUIRE(channels == 3);

    // compare against qoi.h result
    qoi_desc desc;
    auto pix = qoi_decode((uint8_t*)qoi_green_square.data(), qoi_green_square.size(), &desc, 0);
    REQUIRE(pix != nullptr);
    REQUIRE(width == desc.width);
    REQUIRE(height == desc.height);
    REQUIRE(channels == desc.channels);
    CHECK(memcmp(pix, decoded, width * height * channels) == 0);

    free(decoded);
}

TEST_CASE("Bad QOI data") {
    // same data as above but too short
    //                            | QOI Header          |            width       |          height      | chnl | csp | stream..
    std::vector<uint8_t> data = {0x71, 0x6f, 0x69, 0x66, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x64, 0x03, 0x00, 0xfe};
    uint32_t width, height, channels;
    auto decoded = magicqoi_decode_mem(data.data(), data.size(), &width, &height, &channels);
    REQUIRE(decoded == nullptr);
}

int main(int argc, char** argv)
{
    // Make sure internal tests work before running Catch2
    mgqoi_internal_self_test();

    // start catch2
    int result = Catch::Session().run(argc, argv);
    return result;
}